{
  "version": 3,
  "sources": ["../plugin/code.ts"],
  "sourcesContent": ["figma.showUI(__html__, { width: 360, height: 320 });\n\ntype MerchantLookup = {\n  name: string;\n  logoUrl: string | null;\n  heroUrl: string | null;\n};\n\ntype MerchantCardNodes = {\n  nameNode: TextNode | null;\n  logoNode: SceneNode | null;\n  heroNode: SceneNode | null;\n};\n\nconst LOOKUP_ENDPOINT = \"http://localhost:8787/lookup?name=\";\n\n/**\n * How to test:\n * 1) cd server && USE_MOCK=true node index.js\n * 2) In Figma, select the \"Merchant Grid\" frame with child \"Merchant Card\" items.\n * 3) Run plugin, enter: Nike, Samsung, Macy's\n * 4) Click Run; first N cards get updated with mock images and names.\n */\n\nasync function fetchLookup(name: string): Promise<MerchantLookup> {\n  const url = `${LOOKUP_ENDPOINT}${encodeURIComponent(name)}`;\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Lookup failed (${response.status}) for ${name}`);\n  }\n  return (await response.json()) as MerchantLookup;\n}\n\nfunction parseMerchantNames(input: string): string[] {\n  return input\n    .split(\",\")\n    .map((value) => value.trim())\n    .filter(Boolean);\n}\n\nfunction getMerchantCards(parent: SceneNode): SceneNode[] {\n  if (!(\"children\" in parent)) return [];\n  return parent.children.filter((child) => child.name === \"Merchant Card\");\n}\n\nfunction findFirstByName(root: SceneNode, name: string): SceneNode | null {\n  if (\"findOne\" in root) {\n    return (root as ChildrenMixin).findOne((node) => node.name === name) as SceneNode | null;\n  }\n  return null;\n}\n\nfunction resolveCardNodes(card: SceneNode): MerchantCardNodes {\n  const nameNode = findFirstByName(card, \"Merchant name\");\n  const logoNode = findFirstByName(card, \"image 162\");\n  const heroNode = findFirstByName(card, \"image 161\");\n\n  return {\n    nameNode: nameNode?.type === \"TEXT\" ? nameNode : null,\n    logoNode,\n    heroNode,\n  };\n}\n\nasync function setText(node: TextNode, value: string) {\n  await figma.loadFontAsync(node.fontName as FontName);\n  node.characters = value;\n}\n\nfunction supportsFills(node: SceneNode): node is GeometryMixin {\n  return \"fills\" in node;\n}\n\nasync function loadImageBytes(url: string): Promise<Uint8Array> {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Image fetch failed (${response.status})`);\n  }\n  const buffer = await response.arrayBuffer();\n  return new Uint8Array(buffer);\n}\n\nasync function setImageFill(node: SceneNode, url: string) {\n  if (!supportsFills(node)) {\n    console.warn(`Node ${node.name} does not support fills.`);\n    return;\n  }\n\n  const fills = Array.isArray(node.fills) ? [...node.fills] : [];\n  if (fills.length === 0) {\n    console.warn(`Node ${node.name} has no fills; skipping image update.`);\n    return;\n  }\n\n  const bytes = await loadImageBytes(url);\n  const image = figma.createImage(bytes);\n  const imagePaint: ImagePaint = {\n    type: \"IMAGE\",\n    imageHash: image.hash,\n    scaleMode: \"FILL\",\n  };\n\n  let replaced = false;\n  for (let i = 0; i < fills.length; i++) {\n    if (fills[i].type === \"IMAGE\" || fills[i].type === \"SOLID\") {\n      fills[i] = imagePaint;\n      replaced = true;\n      break;\n    }\n  }\n\n  if (!replaced) {\n    fills[0] = imagePaint;\n  }\n\n  node.fills = fills;\n}\n\nasync function populateCards(parent: SceneNode, merchants: MerchantLookup[]) {\n  const cards = getMerchantCards(parent);\n  if (cards.length === 0) {\n    figma.notify('No \"Merchant Card\" children found in the selection.');\n    return;\n  }\n\n  const count = Math.min(cards.length, merchants.length);\n  console.log(`Populating ${count} cards...`);\n\n  for (let index = 0; index < count; index += 1) {\n    const card = cards[index];\n    const merchant = merchants[index];\n    const { nameNode, logoNode, heroNode } = resolveCardNodes(card);\n\n    if (nameNode) {\n      await setText(nameNode, merchant.name || \"\");\n    } else {\n      console.warn(`Missing Merchant name node on card ${index + 1}`);\n    }\n\n    if (logoNode && merchant.logoUrl) {\n      try {\n        await setImageFill(logoNode, merchant.logoUrl);\n      } catch (error) {\n        console.warn(`Logo image failed for ${merchant.name}:`, error);\n      }\n    }\n\n    if (heroNode && merchant.heroUrl) {\n      try {\n        await setImageFill(heroNode, merchant.heroUrl);\n      } catch (error) {\n        console.warn(`Hero image failed for ${merchant.name}:`, error);\n      }\n    }\n  }\n\n  figma.notify(`Done: filled ${count} cards`);\n}\n\nfigma.ui.onmessage = async (msg) => {\n  if (msg?.type !== \"RUN_MERCHANT_AUTOFILL\") return;\n\n  const payload = typeof msg.payload === \"string\" ? msg.payload : \"\";\n  const names = parseMerchantNames(payload);\n\n  if (names.length === 0) {\n    figma.notify(\"Please enter at least one merchant name.\");\n    return;\n  }\n\n  const selection = figma.currentPage.selection;\n  if (selection.length !== 1) {\n    figma.notify(\"Select exactly one layer: Merchant Grid.\");\n    return;\n  }\n\n  const parent = selection[0];\n  if (\n    parent.type !== \"FRAME\" &&\n    parent.type !== \"GROUP\" &&\n    parent.type !== \"COMPONENT\"\n  ) {\n    figma.notify(\"Selection must be a frame containing Merchant Cards.\");\n    return;\n  }\n\n  figma.notify(`Looking up ${names.length} merchants...`);\n\n  try {\n    const merchants = [];\n    for (const name of names) {\n      try {\n        const result = await fetchLookup(name);\n        merchants.push(result);\n      } catch (error) {\n        console.warn(`Lookup failed for ${name}:`, error);\n        merchants.push({ name, logoUrl: null, heroUrl: null });\n      }\n    }\n\n    await populateCards(parent, merchants);\n  } catch (error) {\n    console.warn(\"Unexpected error:\", error);\n    figma.notify(\"Something went wrong while filling cards.\");\n  } finally {\n    figma.closePlugin();\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
